spring框架
	spring：在2002年出现，解决企业级开发
		帮助开发人员创建对象，管理对象之间的关系

	spring核心技术：IOC AOP 能实现模块之间，类之间的解耦合。

	依赖：
		class A中使用了class B的属性或者方法。A依赖于B
		spring能管理A和B之间的关系
	
	spring轻量，可以集成其他框架

框架是其他人写好的软件
	需要知道框架能干什么 mybatis可以访问数据库
	需要知道框架的语法
	框架的内部实现

spring第一个核心功能 ioc：Inversion of Contorl 控制反转，是一个理论
	描述：把对象的创建，赋值，管理等工作都交给容器实现。对象的创建由外部资源来完成
	spring也称为容器

	控制：创建对象，对象赋值，对象之间的关系管理
	反转：
		正转：开发人员使用new，开发人员主动管理对象
		反转：把开发者管理创建对象的权限转移给代码之外的容器实现。由容器来代替开发者管理和创建对象
	
	容器是一个服务器软件，一个框架

	作用：
		减少对代码的改动也能实现不同的功能。实现解耦合

    适合使用spring的对象：
        dao类，service类，controller类，工具类
        spring中的对象默认是单例的，在容器中叫这个名的对象只有一个
    不适合在spring中的对象：
        实体类：实体类的数据来自数据库
        servlet，监听器，过滤器（由tomcat创建）
    如何把对象放到容器中：
        使用xml文件：使用《bean》
        使用注解

java中创建对象的方式：
	1.构造方法 new
	2.反射
	3.序列化
	4.克隆
	5.ioc：容器创建对象-----不需要再程序中写代码
	6.动态代理

ioc的体现：
	servlet：
		1.创建类继承HttpServlet
		2.再web.xml注册Myservlet
		3.没有创建过Myservlet对象
		4.Servlet对象是tomcat服务器帮助创建的
		tomcat也称为容器：
			里面存放的有：监听器，过滤器
	
ioc的技术实现
	DI 依赖注入
		只需要在程序中提供要使用的对象名称，对象如何创建赋值查找都由容器实现（容器里有个工程师）
	spring使用di实现了ioc功能，spring底层创建对象使用的是反射

	ioc：控制反转
	    是一种思想，指导开发者在容器中，在代码之外，给属性赋值，管理依赖

	spring使用DI技术，底层使用反射机制

	Di给属性赋值
	    set注入：使用set方法
	        1.简单类型的set注入
	             <property name="属性名" value="属性值" />
	        2.引用类型的set注入
	            <property name="属性名" ref="bean的id（对象名称）" />
	    构造注入:使用有参数的构造方法
	        使用<constructor-arg>标签
	            1.使用name属性：形参名
	            2.使用index属性：形参的位置

使用spring的步骤：
    1.加入依赖
        <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>spring-context</artifactId>
              <version>5.2.5.RELEASE</version>
        </dependency>
    2.创建类
    3.创建spring的配置文件，使用bean声明对象
    4.使用对象，使用applicationContext接口和它的实现类：ClassPathXmlApplicationContext的getBean（）得到对象


对象的赋值
    1.基于xml的DI

    2.基于注解的DI【重要】
        @override就是一个注解

 多个配置文件
    1.每个文件都小，打开很块
    2.避免多人竞争带来的冲突
        一个模块一个配置文件
    分配方式：
        1.按业务功能
        2.按类的功能（数据库功能，事物相关，service相关）

基于注解的DI【重要】
    通过注解完成java对象的创建和属性赋值

    使用步骤：
        1.加入maven的依赖 spring-context，在加入spring-context的同时，间接加入spring-aop的依赖。
            使用注解必须使用spring-aop依赖
        2.在类中加入spring注解
        3.在spring的配置文件中，加入一个组件扫描器的标签，说明注解在项目中的位置

    自动注入：
        由spring根据某些规则，给引用类型赋值
        常用byName和byType方式
            byName：按名称注入
                java类中引用类型的属性名和spring容器中bean的id一样，数据类型一样，这样的bean赋值给引用类型
            byType：
                java类中引用类型的数据类型和spring容器中bean的class是同源关系的，这样的bean能赋值给引用类型

    需要学习的注解：
        1.@Component
            用于创建对象（普通对象）
        2.@Respotory
            创建dao对象（访问数据库）
        3.@Service
            创建service对象（处理业务逻辑）有事物功能
        4.@Controller
            创建控制器对象的，接收请求，显示处理结果
        5.@Value
            简单类型的赋值
        6.@Autowired
            spring中引用类型的赋值（byName和byTyep，默认使用byType）
        7.@Resource
            jdk中引用类型的赋值（默认使用byName）

        注解的使用步骤：
            1.加入依赖：
                spring-context 间接加入 spring-aop
            2.在类中加入注解
            3.在spring的配置文件中，加入组件扫描器的标签，<context:component-scan base-package="org.example.ba07" />

ioc可以实现解耦合
    ioc实现业务对象之间的解耦合：service和dao对象之间的解耦合



aop------面向切面编程

    动态代理：能创建对象，原有代码不改动的情况下可以实现功能的增加和功能的增强，减少重复代码，专注业务逻辑
        两种实现方式：
            jdk动态代理：要求目标类必须有接口
                使用Proxy Method InnovationHandler三个类实现动态代理
            CGLIB动态代理：不许需要有接口（使用继承的方式）
                对类的要求低，只要能继承就行，子类就是代理对象

    动态代理规范化：aop，aop的底层就是动态代理，设计aop是为了规范化

    aop面向切面编程，基于动态代理，可以使用jdk和cglib两种方式。
        Aspect：切面，给目标类增加的功能就是切面（例子中的日志，提交等）
            切面的特点：一般都是非业务方法，可以独立使用
        Orient：面向
        Programing：编程

        理解：
            oop：面向对象编程。程序设计时，把功能分程不同的对象实现。程序由不同的类组成，基于对象构建对象
            aop：分析找出切面，考虑切面在什么地方执行
                1、分析项目功能时找出切面（最难）
                2、合理安排切面执行的时间（目标方法前还是目标方法后）
                3、合理安排切面执行的位置，在哪个类，哪个方法增加功能

        术语：
            Aspect：切面，表示增强功能，就是一堆代码完成某个功能，一般是非业务功能。
                常见的切面的功能：日志，事务，统计信息，参数检查，权限验证
            JoinPoint：连接点（业务方法），连接业务方法和切面的位置。就是某个类中的业务方法（例子中的dosome方法）
            PiontCut：切入点，多个连接点方法的集合。多个方法（这些方法都要加入切面）
            目标对象：给哪个类增加功能，这个类就是目标对象
            Advice：通知，表示切面的功能执行的时间（目标方法之前还是之后）

        一个切面有三个关键要素：
            1.切面的功能代码：切面干什么
            2.切面的执行位置：PointCut表示
            3.切面的执行时间：Advice表示

    aop的实现：
        aop是个规范，是对动态代理的规范化
        aop的技术实现框架：
            1、spring内部实现了aop的规范
                spring在事务处理使用aop
                项目开发中很少使用spring的实现，因为spring笨重
            2、aspectJ：开源的专门做aop的框架。spring框架中集成了aspectJ框架
                aspectJ实现aop的两种方式：
                    1、使用xml配置文件：配置全局事务
                    2、使用注解【项目中一般都使用注解】
                        5个注解

    aspectJ框架的使用：
        1、切面的执行时间，这个执行时间在规范中叫做advice（通知、增强）
            在aspectJ框架中使用注解表示（也可以使用xml文件中的标签）
                @Before
                @AfterReturning
                @Around
                @AfterThrowing（很少用）
                @After（很少用）
                @PointCut
                    管理切入点的，在项目中多个切入点是想用的可以复用，使用这个
                    在自定义方法上面使用，自定义方法名可以代替原切入点表达式
        2、执行的位置，使用切入点表达式
            execution(modifiers-pattern? ret-type-pattern
                     declaring-type-pattern?name-pattern(param-pattern)
                     throws-pattern?)

            modifiers-pattern:访问权限（public privacy）
            ret-type-pattern：返回值类型【必须】
            declaring-type-pattern：包名类名
            name-pattern(param-pattern)：方法名（参数类型和参数个数）【必须】
            throws-pattern：抛出异常类型
            ？：可选部分

            *：任意个字符
            ..:在方法参数中，表示任意个参数。用在包名后，表示当前包及其子包路径
            +：用在类名后，表示当前类及其子类。用在接口后，表示当前接口及其实现类

                ps：execution（public * *(..)）//只要方法是用public修饰的，不管方法名，返回值，方法参数。都可以加入切面功能
                    execution（* set*（..））//任何一个以set开始的方法都可以加入切面功能
                    execution（* com.xyz.service.*.*(..)）
                    //com.xyz.service.*这个包中的所有类   类.表示这个类中的方法
                    //表示这个包中的任意类，任意类中的任意方法，方法参数是任意的
                    execution（* com.xyz.service..*.*(..)）//com.xyz.service包和子包中所有类的所有方法
                    execution(* *..service.*.*(..))//在service包上级可以有多级包